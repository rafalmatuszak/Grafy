#import random
#import math

##function for loading graph from text file
#def load_graph():
#    return {int(line.rstrip().split()[0]): [int(i) for i in line.rstrip().split()[1:]] for line in open("source2.txt")}    

##printing graph as combinations of key:value
#def print_graph(graph):
#    for k,v in graph.items():
#        print(k)
#        print(v)

#def contract_edge(edge):
#    global graph

#    #merging verticies from cutted edges
#    v1l = graph[edge[1]]
#    v1l.extend(graph[edge[1]])
#    del graph[edge[1]]

#    for k,l in graph.items():
#        graph[k] = [edge[0] if x == edge[1] else x for x in graph[k]]

#    graph[edge[0]] = [x for x in graph[edge[0]] if x != edge[0]]

#def get_random_edge():
#    v1 = list(graph.keys()) [random.randint(0,len(graph)-1)]
#    v2 = graph[v1] [random.randint(0,len(graph[v1])-1)]
#    return (v1,v2)



#minList = []

#for x in range(0,20):
#    graph = load_graph()
    
#    while(len(graph) > 2):
#        contract_edge(get_random_edge())

#    minList.append(len(graph(graph.keys()[0])))

#print(min(minList))


####TO Z KLASAMI

import random
 
class Node:
    '''
        Definition for Node class
    '''
    def __init__(self, id):
        self.id = id
        self.edges = {}

    def add(self, id, num):
        if id != self.id:
            self.edges[id] = self.edges.get(id, 0) + num 

    def remove(self, id):
        try:
            del self.edges[id]
        except KeyError:
            pass

    def merge(self, id1, id2):
        if id2 in self.edges:
            self.edges[id1] = self.edges.get(id1, 0) + self.edges[id2]            
            self.remove(id2)

    def size(self):
        return sum(self.edges.values())

    def copy(self):
        node = Node(self.id)
        node.edges = dict(self.edges)
        return node

    def __equals__(self, other):
        return self.id == other.id

    def __str__(self):
        return str({self.id : self.edges})
 
 
class graph:
    '''
        Definition for graph class
    '''
    def __init__(self, nodes): 
        self.nodes = {node.id : node.copy() for node in nodes}
    
    def combine(self, id1, id2):
        if id1 not in self.nodes or id2 not in self.nodes[id1].edges:
            return
        for id in self.nodes[id2].edges:
            self.nodes[id1].add(id, self.nodes[id2].edges[id])
        try:
            del self.nodes[id2]
            del self.nodes[id1].edges[id2]
        except KeyError:
            pass
        for id in self.nodes:
            self.nodes[id].merge(id1, id2)
    
    def randomCombine(self):
        node1 = random.choice(list(self.nodes.values()))
        id1 = node1.id
        id2 = random.choice(list(node1.edges.keys()))
        self.combine(id1, id2)
    
    def size(self):
        return len(self.nodes)
    
    def __str__(self):
        return '\n'.join([str(node) for node in self.nodes.values()])
 
 
f = open('source2.txt', 'r')
lines = f.readlines()
n = len(lines)
nodes = []
for line in lines:
    ids = [int(id) for id in line.split()]
    node = Node(ids[0])
    for id in ids[1:]:
        node.add(id,1)
    nodes.append(node)
 
rawSet = graph(nodes)
print(rawSet)
 
cuts = []
for i in range(n**2):
    rawSet = graph(nodes)
    while rawSet.size() > 2:
        rawSet.randomCombine()
    id1 = list(rawSet.nodes.keys())[0]
    id2 = list(rawSet.nodes.keys())[1]
    size1 = rawSet.nodes[id1].size()
    size2 = rawSet.nodes[id2].size()
    assert size1 == size2, "Node size not equal: %d and %d" % (size1, size2)
    cuts.append(size1)
 
print("Min cuts: ",min(cuts))